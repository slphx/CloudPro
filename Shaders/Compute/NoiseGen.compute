#pragma kernel NoiseGenMain

#define THREAD_GROUP_SIZE 8

#include "Noiselib/NoiseLib.hlsl"

// enum NoiseType {0:Hash, 1:Perlin};
int _NoiseType;
int _Resolution;
float _InvResolution;
int _Seed;
float _Frequency;
bool _IsTiling;
int _Octaves;
bool _Inverse;

RWTexture3D<float4> _Noise;

float getNoise(float3 pos, float frequency) {
    float noise = 0.0;
    // Perlin Noise 2D
    if (_NoiseType == 1) {
        noise = 0.5 + 0.5 * Perlin2D(pos.xy, frequency, _IsTiling);
    }
    // Perlin Noise 3D
    else if (_NoiseType == 2) {
        noise = 0.5 + 0.5 * Perlin3D(pos.xyz, frequency, _IsTiling);
    }
    // Worley Noise 2D
    else if (_NoiseType == 3) {
        noise = Worley2D(pos.xy, frequency, _IsTiling);
    }
    // Worley Noise 3D
    else if (_NoiseType == 4) {
        noise = Worley3D(pos.xyz, frequency, _IsTiling);
    }

    return noise;
}

float dilatePerlinWorley(float p, float w, float x){
	float curve = 0.75;
	if(x < 0.5){
		x /= 0.5;
		float n = p + w * x;
		return n * lerp(1, 0.5, pow(x,curve));
	}
	else{
		x = (x-0.5)/0.5;
		float n = w + p *(1.0 - x);
		return n * lerp(0.5, 1.0, pow(x, 1.0/curve));
	}
}

[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, THREAD_GROUP_SIZE)]
void NoiseGenMain(uint3 id: SV_DispatchThreadID) {
    float3 pos = float3(id.x, id.y, id.z) * _InvResolution;

    const float G = 0.5,    // 振幅变化倍率
                FG = 2.0;   // 频率变化倍率

    float   value = 0.0, 
            frequency = _Frequency,
            amplitude = 1.0,
            sumAmplitude = 0.0;

    pos += _Seed * hash13(_Seed);

    // Hash Noise
    if (_NoiseType == 0) {
        value += 0.5 + 0.5 * hash31(id.xyz + 
                            _Seed * float3(hash11(id.x + _Seed), hash11(id.y + _Seed), hash11(id.z + _Seed)));
    } else if (_NoiseType <= 4){
        for (int i=0; i<_Octaves; i++) {
            sumAmplitude += amplitude;
            value += amplitude * getNoise(pos, frequency);
            amplitude *= G;
            frequency *= FG;
        }
        value /= sumAmplitude;
        if (_Inverse) value = 1.0 - value;
    } else if (_NoiseType == 5) {

        float v0 = 0.0, f0 = 4, a0 = 1.0, s0 = 0.0,
              v1 = 0.0, f1 = _Frequency, a1 = 1.0, s1 = 0.0;
        // Perlein-Worley Noise
        for (int j=0; j<_Octaves; j++) {
            s0 += a0;
            v0 += a0 * (0.5 + 0.5 * Perlin3D(pos.xyz, f0, _IsTiling));
            a0 *= G;
            f0 *= FG;
        }
        v0 /= s0;

        for (int i=0; i<_Octaves; i++) {
            s1 += a1;
            v1 += a1 * Worley3D(pos.xyz, f1, _IsTiling);
            a1 *= G;
            f1 *= FG;
        }
        v1 /= s1;
        
        float Perlin = v0;
        float Worley = 1 - v1;
        value = dilatePerlinWorley(Perlin, Worley, 0.8);
        // value = (a * v0 + (1 - a) * (1 - v1));

        // if (_Inverse) value = 1 - value;
    }

    _Noise[id.xyz] = value;
}